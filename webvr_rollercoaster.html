<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Basic WebGl Demo - MT</title>
		<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	</head>
	<body>
		<script src="three.js"></script>
		<script src="OBJLoader.js"></script>
		<script>
			var renderer = new THREE.WebGLRenderer( { antialias: true } ),
			camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 1500 ),
			scene = new THREE.Scene();

			scene.background = new THREE.Color( 0x3fb8ff );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			var manager = new THREE.LoadingManager( loadModels ),
			textureLoader = new THREE.TextureLoader( manager ),
			texture = textureLoader.load( 'UV_Grid_Sm.jpg' , function(texture){
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.offset.set( 0, 0 );
				texture.repeat.set( 16, 16 );
			}),

			loader = new THREE.OBJLoader( manager );
			loader.load( './car.obj', function ( obj ) { playerOneCar = obj; });
			loader.load( './track.obj', function ( obj ) { track = obj; });
			const cube = new THREE.Mesh(
			new THREE.BoxGeometry(12552.5, 2.5, 12552.5)
			);
			var geometry = new THREE.CylinderGeometry( 2, 2, 15 , 16 );
			var material = new THREE.MeshBasicMaterial( {color: 0x000} );
			var rearTire = new THREE.Mesh( geometry, material );

			var geometry = new THREE.CylinderGeometry( 2, 2, 15 , 16 );
			var material = new THREE.MeshBasicMaterial( {color: 0x000} );
			var frontTire = new THREE.Mesh( geometry, material );
			
			
			var loader = new THREE.FontLoader();
			var countdown;
			var iteration = 4;
			function readySetGo(){
			loader.load( 'helvetiker_regular.typeface.json', function ( font ) {
				scene.remove( countdown );

				if (iteration == 1) iteration = "GO!"
				if (iteration == -1) iteration = ""
				if (Number.isInteger(iteration)) iteration--

				var geometry = new THREE.TextGeometry( iteration.toString(), {
					font: font,
					size: 20,
					height: 1,
					curveSegments: 12,
					bevelEnabled: true,
					bevelThickness: 1,
					bevelSize: 1,
					bevelSegments: 1
				} );
				THREE.GeometryUtils.center( geometry );
				var textMaterial = new THREE.MeshPhongMaterial( 
					{ color: 0xffff00, specular: 0xffffff }
				);
				countdown = new THREE.Mesh( geometry, textMaterial );
				scene.add( countdown );
				countdown.position.set(150, 5,165)
				countdown.rotation.y = toRadians(90)
			} );
		}
			
			cube.material.transparent=true;
			cube.material.opacity=0.9;
			cube.material.map = texture;
			
			cube.material.color.setHex( 0x0000ff );
			scene.add(cube)
			cube.position.set(0,-650,0)

			function loadModels() {
				playerOneCar.traverse( function ( child ) {
					if ( child.isMesh ) child.material.color.setHex( 0xff0000 );
					scene.add(playerOneCar)
				} );

				rearTire.rotation.x = toRadians(90)
				rearTire.position.set(-9,1.5,0.3)
				playerOneCar.add( rearTire );

				frontTire.rotation.x = toRadians(90)
				frontTire.position.set(7,1.5,0.3)
				playerOneCar.add( frontTire );


				track.traverse( function ( child ) {
					scene.add(track)
					track.position.set(50,540,-1160)
					track.scale.set(25,25,25);
				} );
				renderer.setAnimationLoop( render );
				countdown321();
			}

			var velocityX, velocityZ;

			var reboundX = 0, reboundZ = 0;

			var velocity = {
				current: 0
			}

			var sphere = new THREE.SphereBufferGeometry( 0.5, 116, 8 );


			light1 = new THREE.PointLight( 0xffffff,1, 5155 );
			light1.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffffff } ) ) );
			scene.add( light1 );
			light1.position.set(1440,1222,0)
			light2 = new THREE.PointLight( 0xffffff,1, 6155 );
			light2.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffffff } ) ) );
			scene.add( light2 );
			light2.position.set(-540,1222,440)

			var light = new THREE.HemisphereLight( 0xfff0f0, 0x606066, 0.2 );
			light.position.set( 1, 1, 1 );
			scene.add( light );

			function Player(xCoord, yCoord, zCoord, rotation) {
				this.x = xCoord;
				this.y = yCoord;
				this.z = zCoord;
				this.lap = 1;
				this.rotation = rotation;
				this.chase = false;
				this.checkpoint = false;
			}

			var p1 = new Player(220, -76,163, 180);
			
			var keyDown = {
				w:false,
				a:false,
				s:false,
				d:false
			}

			var rayCast = {
				rays : {
					frontL:[0, 10, 0, -20, function(hitCoord){
							if (hitCoord > 854) {
								velocity.current = velocity.current/1.35
								p1.rotation--
								p1.rotation--
								p1.rotation--
								p1.rotation--
							} else if (hitCoord < 4 && p1.y > -743) {

							}
						}
					],
					frontR:[12,10,0,20,function(hitCoord){
							if (hitCoord > 854) {
								velocity.current = velocity.current/1.35
								p1.rotation++
								p1.rotation++
								p1.rotation++
								p1.rotation++
							}
						}
					],
					rearL:[0,10,12,200,function(hitCoord){
						if (hitCoord > 854) {
							velocity.current = velocity.current/1.1
							p1.rotation--
						}
					}],
					rearR:[12,10,12,160,function(hitCoord){
						if (hitCoord > 854) {
							velocity.current = velocity.current/1.1
							p1.rotation++

						}
					}]
				},
				makeRays: function() {
					var count = 0;
					Object.entries(this.rays).forEach(function(entry) {
						var cast = new THREE.Raycaster();
						cast.ray.origin.set(entry[1][0],entry[1][1]+1110,entry[1][2]);
						cast.ray.direction.set( 0, - 1, 0 );
						var hit = cast.intersectObject(track, true);
						entry[1][0] = p1.x + 14 * Math.cos(toRadians(entry[1][3]-p1.rotation));
						entry[1][2] = p1.z + 14 * Math.sin(toRadians(entry[1][3]-p1.rotation));
						if(hit[0] != undefined) {
							var hitCoord = hit[ 0 ].point.y;
							if(entry[0]=="frontR")
							entry[1][4](hitCoord)
						} else {
							count++
						}
						
					});

					if (count == 4 && p1.y > -780 ||  p1.y < -90 && p1.y > -780){
						p1.y += -5;
						p1.chase=false;
						
					}
				}
			}

function render() {
	

	velocityX = p1.x + (velocity.current + reboundX) * Math.cos(toRadians(-0-p1.rotation));
	velocityZ = p1.z + (velocity.current + reboundZ) * Math.sin(toRadians(-0-p1.rotation));
	p1.x=velocityX
	p1.z=velocityZ
	playerOneCar.rotation.y = toRadians(p1.rotation);
	playerOneCar.position.set(p1.x, p1.y, p1.z)



	Number.isInteger(iteration) && countdown ? countdown.position.y--  : null

	if (p1.chase) {playerOneCar.add( camera );camera.lookAt(p1.x,p1.y+20,p1.z);} else {playerOneCar.remove( camera );camera.position.set(p1.x+200,p1.y+400,p1.z); camera.lookAt(p1.x,p1.y+20,p1.z);}
	rayCast.makeRays()
	renderer.render( scene, camera );
	if (Number.isInteger(iteration)) return;
	if (keyDown.w == true) {
		velocity.current += 0.02
	}
	console.log(p1.y)
	if (keyDown.a == true && velocity.current > 0.1 || keyDown.d == true && velocity.current < -0.1 ) {
		p1.rotation++
	}
	if (keyDown.s == true) {
		velocity.current += -0.1
	}
	if (keyDown.d == true && velocity.current > 0.1 || keyDown.a == true && velocity.current < -0.1) {
		p1.rotation--
	}

	if (velocity.current > 0 && keyDown.w != true) {
		
		velocity.current += -0.02
	}
	if (velocity.current < 0) {
		velocity.current += 0.02
	}


}

function toRadians (angle) {
	return angle * (Math.PI / 180);
}

function key(event) {
	let down;
	event.type == "keydown" ? down = true : down = false;
	switch (event.key) {
		case "W": case "w": 
			keyDown.w = down;
			break;
		case "A": case "a": 
			keyDown.a = down;
			break;
		case "S": case "s": 
			keyDown.s = down;
			break;
		case "D": case "d": 
			keyDown.d = down;
			break;
		case "C": case "c":
			if (!down) {
				if (p1.chase) {p1.chase=false;} else {p1.chase=true;camera.position.set(-100,20,0);} 
			}
		
	}
}
document.addEventListener("keyup", key);
document.addEventListener("keydown", key);

window.addEventListener( 'resize', function() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}, false );



	var oneSecondInterval;
	function countdown321() {
		oneSecondInterval = setInterval(function(){ myTimer() }, 1000);
	}
	
	function myTimer() {

	readySetGo()
	if (iteration == "GO!") {

		iteration = "";
		clearInterval(oneSecondInterval);
		
	}
	}



</script>
</body>
</html>
